---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.14.5
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# Additional Tutorial on LLRGs

Although most LLRGs are straightforward, there are still some LLRGs that takes a long time to understand. This is a tutorial to correctly use different LLRGs to simulate different sequencers. We assume that you had already read _YASIM Tutorial_.

Here we would demonstrate features of commonly-used LLRGs using mitochondria of _C. Elegans_.

```{figure} ../fig/llrg_step.svg
:width: 100%
:align: left
:alt: LLRG Step Flow Chart

LLRG Step Flow Chart

This figure demonstrates the basic workflow of the LLRG step. It is, in details, as follows:

1. The input cDNA sequences and depths are separated by isoform's transcript ID.
2. For each transcript, its cDNA sequence and depth are passed into LLRG adapter, which performs DNA-Seq on those cDNAs and generates reads in FASTQ format.
3. The LLRG adapters are executed in parallel.
4. Generated reads would be merged into one (SE) or two (PE) files.
```

## Preparations

Here generates all steps before proceeding into LLRG. Note that generation of AS events is optional so not used.

```{code-cell} ipython2
!if [ ! -f chrM.fa ]; then \
    axel https://hgdownload.soe.ucsc.edu/goldenPath/ce11/bigZips/chromFa.tar.gz; \
    tar xzvf chromFa.tar.gz; \
    rm -f chrI.fa chrII.fa chrIII.fa chrIV.fa; \
else \
    echo "chrM.fa already exists."; \
fi

!if [ ! -f chrM.ncbiRefSeq.gtf ]; then \
    axel https://hgdownload.soe.ucsc.edu/goldenPath/ce11/bigZips/genes/ce11.ncbiRefSeq.gtf.gz; \
    gzip -cfd ce11.ncbiRefSeq.gtf.gz | grep '^chrM\s' > chrM.ncbiRefSeq.gtf ; \
else \
    echo "chrM.ncbiRefSeq.gtf already exists."; \
fi

!if [ ! -f isoform_depth.tsv ]; then \
    python -m yasim generate_gene_depth \
        -g chrM.ncbiRefSeq.gtf \
        -o gene_depth.tsv \
        -d 10 \
    2>&1 | grep -v 'inferred from feature transcript'; \
    python -m yasim generate_isoform_depth \
        -g chrM.ncbiRefSeq.gtf \
        -d gene_depth.tsv \
        -o isoform_depth.tsv \
        --alpha 4; \
else \
    echo "isoform_depth.tsv already exists."; \
fi

!if [ ! -f chrm_trans.fa ]; then \
    python -m labw_utils.bioutils transcribe \
    -g chrM.ncbiRefSeq.gtf \
    -f chrM.fa \
    -o chrm_trans.fa; \
else \
    echo "chrm_trans.fa already exists."; \
fi
```

## ART

```{code-cell} ipython2

```

## DWGSIM

+++

## PBSIM

PBSIM version 1 can simulate data generated by PacBio RS, a very old sequencer that is not commonly seen nowadays. It has a CCS mode.

```{warning}
PBSIM generates CCS with a mechanism similiar to CLR. It does **NOT** require invocation of PacBio `ccs` utility.
```

+++

## PBSIM2

PBSIM2 can simulate early PacBio RS II and ONT models. It does **NOT** support CCS generation.


+++

## PBSIM3

PBSIM3 is one of the most complicated LLRGs used in this software. Comparing to PBSIM3, it has following additional parameters:

### Stratergy

PBSIM3 have 2 strategy: `wgs` and `trans`. Their difference is as follows:

- The `wgs` strategy is same as what is used in PBSIM2, PBSIM, and other LLRGs. i.e., PBSIM3 was used as a DNA-Seq simulator that reads cDNA and outputs sequences.
- The `trans` strategy is new in PBSIM3. It would generate reads based on a new PBSIM3-specific isoform record format and was claimed to be able to simulate 3' read truncation.

### HMM Method

PBSIM3 have 2 HMM method: Error HMM and Quality Score HMM. The former would not generate quality scores in output FASTQ.

### CCS

Circular Consensus Sequence (CCS)/HiFi Reads are commonly used in PacBio sequencing as it provides user with higher accuracy that is comparable to NGS reads. See [official site](https://ccs.how/) for more details.

YASIM can generate CCS FASTQ. The `--ccs_pass` parameter determines number of passes to perform when simulating CCS reads. To simulate CLR reads, do not set `--ccs_pass` or set `--ccs_pass` to 1. If this parameter is set to other value, simulated data would be in CCS.

On CCS generation, YASIM would firstly invoke PBSIM3 to generate PacBio CLR reads, and then call CCS using `ccs` from pacBio. This requires `samtools` and `ccs` to be present. You may set their path in corresponding parameters.

For IsoSeq-based pipeline that requires CCS BAM, please refer to the appendix.

The MAF generated in CCS mode is paired with generated CLR reads and cannot reflect error status of generated CCS reads.

+++

## Badread

+++

## Appendices

+++

### Using PacBio IsoSeq Pipelines

```{warning}
In this mode, `truncate_ratio_5p` and `truncate_ratio_3p` cannot be effective.
```

CCS reads generated by `pbsim3` can be used in officially supported PacBio [IsoSeq](https://isoseq.how) pipelines.

To finish this tutorial, you need to install PacBio [SMRTLink](https://www.pacb.com/support/software-downloads/) or its community version. The latter is recommended. Version of Dependencies:

```{code-cell} ipython2
!pbmerge --version | head -n 1
!pbindex --version | head -n 1
!samtools --version | head -n 1
!ccs --version | head -n 1
!pbmm2 --version | head -n 1
!isoseq3 --version | head -n 1
```

Generation of CCS reads. We would use PacBio Sequel for example.

```{code-cell} ipython2
!if [ ! -f chrm_ccs_isoseq.fq ]; then \
    python -m yasim pbsim3 \
        -m SEQUEL \
        -M errhmm \
        -e /home/yuzj/bin/pbsim3 \
        -F chrm_trans.fa.d \
        -d isoform_depth.tsv \
        -o chrm_ccs_isoseq \
        -j 40 \
        --ccs_pass 10; \
else \
    echo "chrm_ccs_isoseq.fq already exists."; \
fi
```

Merge all small CCS BAMs into single CCS BAM. The file `merge.py` is provided as follows:

```{literalinclude} merge.py
:language: python
```

```{code-cell} ipython2
!if [ ! -f chrm_ccs_isoseq.ccs.bam ]; then \
    python merge.py chrm_ccs_isoseq.ccs.bam chrm_ccs_isoseq.d/*/tmp.ccs.bam; \
    pbindex chrm_ccs_isoseq.ccs.bam; \
    samtools index chrm_ccs_isoseq.ccs.bam \
else \
    echo "chrm_ccs_isoseq.ccs.bam already exists."; \
fi
```

Then you can use standard PacBio IsoSeq pipeline. For example:

```{code-cell} ipython2
!isoseq3 cluster \
    chrm_ccs_isoseq.ccs.bam \
    chrm_ccs_isoseq.transcripts.xml \
    --log-level INFO \
    --num-threads 40
!pbmm2 align \
    --preset ISOSEQ \
    --sort \
    --log-level INFO \
    chrm_ccs_isoseq.transcripts.xml.hq.bam \
    chrM.fa \
    chrm_ccs_isoseq.aln.bam
!isoseq3 collapse \
    --do-not-collapse-extra-5exons \
    --log-level INFO \
    chrm_ccs_isoseq.aln.bam \
    chrm_ccs_isoseq.ccs.bam \
    chrm_ccs_isoseq.collapse.gff
```

The generated annotation file would be available at `chrm_ccs_isoseq.collapse.gff`. You are free to use `gffcompare` or `pigeon` for further analysis.

+++

### Interpretation of LLRG Exceptions

After each simulation, the LLRG adapter would print a line like this: `2023-04-03 15:16:41,070	[INFO] Status of errors: {'NORMAL': 5, 'LLRGFail': 6}`. This line indicates LLRG exception status. Below the definition of commonly-seen exceptions:

- `NORMAL`: If no exception occurs
- `EmptyOutFile`: If LLRG exited normally but with empty output file.
- `NoOutputFile`: If LLRG exited normally but with no output file.
- `LLRGFail`: If LLRG exited abnormally.
- `InitFail`: if pre-execution of initialization hook failed.
- `UNKNOWN`: Other errors.

```{figure} ../fig/llrg_adapter.svg
:width: 100%
:align: left
:alt: LLRG Adapter
```

+++

### Hint on Management of LLRGs

You may use wrapper scripts for LLRGs that requires complex prerequisites.

Following is a wrapper for Badread. This script would:

1. Search for `badread` executable. If succeeded, would execute that executable.
2. Search for `badread` Conda environment. If succeeded, would activate that environment and use `badread` executable inside.
3. Setup `badread` Conda environment and use `badread` executable inside.

```shell
#!/usr/bin/env bash
set -e
if which badread &>> /dev/null; then
    exec badread "${@}"
fi
if ! which conda &>> /dev/null; then
    echo "conda not found!" >&2
    exit 127
fi

if ! conda env list | grep ^badread &>> /dev/null; then
    conda create -y -n badread -c bioconda badread=0.2.0 python-edlib
fi

eval "$(conda 'shell.bash' 'hook' 2> /dev/null)"
conda activate badread
exec badread "${@}"
```

Similar script for PBSIM:

```shell
#!/usr/bin/env bash
set -e
if which pbsim &>> /dev/null; then
    exec pbsim "${@}"
fi
if ! which conda &>> /dev/null; then
    echo "conda not found!" >&2
    exit 127
fi

if ! conda env list | grep ^pbsim &>> /dev/null; then
    conda create -y -n pbsim -c bioconda pbsim=1.0.3
fi

eval "$(conda 'shell.bash' 'hook' 2> /dev/null)"
conda activate pbsim
exec pbsim "${@}"
```
